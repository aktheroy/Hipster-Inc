To integrate your front-end with a Flask backend for translation, you need to follow these steps:

### Step 1: Set Up Your Flask Backend

1. **Install Flask**:
   - Create a virtual environment and install Flask.
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows use `venv\Scripts\activate`
   pip install Flask
   ```

2. **Create a Flask App**:
   - Create a file named `app.py` in your project directory.
   ```python
   from flask import Flask, request, jsonify

   app = Flask(__name__)

   @app.route('/translate', methods=['POST'])
   def translate():
       data = request.json
       source_text = data.get('source_text')
       source_lang = data.get('source_lang')
       target_lang = data.get('target_lang')

       # Placeholder for translation logic
       translated_text = f"Translated ({source_lang} to {target_lang}): {source_text}"

       return jsonify({'translated_text': translated_text})

   if __name__ == '__main__':
       app.run(debug=True)
   ```

3. **Run the Flask App**:
   - Run the Flask app to ensure it works.
   ```bash
   flask run
   ```

### Step 2: Integrate Flask Backend with Front-End

1. **Modify `script.js` to Call Flask API**:
   - Update the `translateBtn` event listener to send a POST request to the Flask backend.
   ```javascript
   document.getElementById('translateBtn').addEventListener('click', function () {
       const sourceText = document.getElementById('sourceText').value;
       const sourceLang = document.getElementById('sourceLang').value;
       const targetLang = document.getElementById('targetLang').value;
       const translatedTextArea = document.getElementById('translatedText');

       fetch('/translate', {
           method: 'POST',
           headers: {
               'Content-Type': 'application/json',
           },
           body: JSON.stringify({
               source_text: sourceText,
               source_lang: sourceLang,
               target_lang: targetLang,
           }),
       })
       .then(response => response.json())
       .then(data => {
           translatedTextArea.value = data.translated_text;
           adjustTextareaHeight(translatedTextArea);
       })
       .catch((error) => {
           console.error('Error:', error);
       });
   });
   ```

2. **Serve Front-End and Back-End Together**:
   - Use a simple HTTP server to serve your front-end files.
   ```bash
   python -m http.server
   ```
   - Ensure your Flask app is running on a different port or use a proxy to serve both front-end and back-end from the same server.

### Step 3: Fine-Tune and Deploy the Translation Model

1. **Model Selection and Fine-Tuning**:
   - Choose a pre-trained model like MarianMT or M2M-100.
   - Fine-tune the model using Hugging Face Transformers on your dataset.
   ```bash
   pip install transformers datasets
   ```
   - Example fine-tuning script:
   ```python
   from transformers import MarianMTModel, MarianTokenizer
   from datasets import load_dataset

   model_name = 'Helsinki-NLP/opus-mt-en-hi'
   tokenizer = MarianTokenizer.from_pretrained(model_name)
   model = MarianMTModel.from_pretrained(model_name)

   dataset = load_dataset('path_to_your_dataset')
   # Fine-tuning code here
   ```

2. **Deploy the Model**:
   - Save the fine-tuned model and upload it to a cloud platform like AWS, Azure, or GCP.
   - Use a framework like FastAPI or Flask to create a REST API for the model.

3. **Update Flask Backend to Use the Fine-Tuned Model**:
   - Replace the placeholder translation logic in `app.py` with the actual model inference.
   ```python
   from transformers import MarianMTModel, MarianTokenizer

   model_name = 'path_to_your_fine_tuned_model'
   tokenizer = MarianTokenizer.from_pretrained(model_name)
   model = MarianMTModel.from_pretrained(model_name)

   @app.route('/translate', methods=['POST'])
   def translate():
       data = request.json
       source_text = data.get('source_text')
       source_lang = data.get('source_lang')
       target_lang = data.get('target_lang')

       # Tokenize and translate
       tokenized_text = tokenizer.prepare_seq2seq_batch([source_text], return_tensors='pt')
       translated = model.generate(**tokenized_text)
       translated_text = tokenizer.decode(translated[0], skip_special_tokens=True)

       return jsonify({'translated_text': translated_text})
   ```

### Step 4: Evaluation and Deployment

1. **Evaluate the Model**:
   - Use BLEU or METEOR metrics to evaluate the model's performance.
   - Compare pre- and post-fine-tuning metrics.

2. **Deploy the API**:
   - Deploy the Flask app with the fine-tuned model on a cloud platform.
   - Ensure the API is scalable and reliable.

3. **Document the API**:
   - Provide clear documentation for the REST API, including endpoints, request/response formats, and example usage.

By following these steps, you will have a fully functional translation application with a Flask backend integrated with your front-end, powered by a fine-tuned translation model.